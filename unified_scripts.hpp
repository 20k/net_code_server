#ifndef UNIFIED_SCRIPTS_HPP_INCLUDED
#define UNIFIED_SCRIPTS_HPP_INCLUDED

#include <string>
#include <vector>
#include <map>
#include <libncclient/nc_util.hpp>
#include "item.hpp"
#include "script_util.hpp"
#include "user.hpp"
#include <secret/special_user_scripts.hpp>

struct unified_script_info
{
    enum class script_type
    {
        SCRIPT,
        BUNDLE,
        C_SHIM,
        PRIVILEGED,
        NONE,
    };

    script_type type = script_type::NONE;

    bool valid = false;
    std::string parsed_source;
    int seclevel = 0;
    bool in_public = false;
    std::string owner;

    std::vector<std::string> args;
    std::vector<std::string> params;

    bool is_c_shim = false;
    std::string c_shim_name;
    std::string name;

    script_metadata metadata;

    void make_from(item& t, const std::string& as_name)
    {
        valid = t.get("valid") == 1;
        parsed_source = t.get_prop("parsed_source");
        seclevel = t.get("seclevel");
        in_public = t.get("in_public");
        owner = t.get("owner");

        args = (std::vector<std::string>)t.get("args");
        params = (std::vector<std::string>)t.get("params");
        metadata.load_from_string(t.get("metadata"));

        name = as_name;
        type = script_type::BUNDLE;
    }

    void make_from(script_info& sinfo)
    {
        valid = sinfo.valid;
        parsed_source = sinfo.parsed_source;
        seclevel = sinfo.seclevel;
        in_public = sinfo.in_public;
        owner = sinfo.owner;

        args = sinfo.args;
        params = sinfo.params;
        metadata = sinfo.metadata;

        name = sinfo.name;
        type = script_type::SCRIPT;
    }

    std::string get_autogenerated_documentation(bool with_examples);
};

unified_script_info unified_script_loading(int thread_id, const std::string& full_scriptname, std::string& err);

#endif // UNIFIED_SCRIPTS_HPP_INCLUDED
